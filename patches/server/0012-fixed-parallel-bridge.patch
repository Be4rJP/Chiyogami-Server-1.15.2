From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: bea4dev <bea0224@outlook.jp>
Date: Mon, 9 Oct 2023 03:56:45 +0900
Subject: [PATCH] fixed parallel bridge


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index acc4a1e81beb60a7de4a0c2aea54b933a3d5d150..71f99cc8299c83708e1990d8a9a9c571508772cd 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -307,6 +307,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     private static final int MAX_SIGN_LINE_LENGTH = Integer.getInteger("Paper.maxSignLength", 80); // Paper
 
     private String clientBrandName = null; // Paper - Brand name
+    @Nullable public world.chiyogami.bridge.ParallelEntityMoveHandler parallelEntityMoveHandler = null; // Chiyogami - VanillaSource parallel bridge
 
     public ServerGamePacketListenerImpl(MinecraftServer server, Connection connection, ServerPlayer player) {
         this.lastChatTimeStamp = new AtomicReference(Instant.EPOCH);
@@ -706,7 +707,17 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                     // note: only call after setLocation, or else getBoundingBox is wrong
                     AABB newBox = entity.getBoundingBox();
                     if (didCollide || !oldBox.equals(newBox)) {
-                        teleportBack = this.hasNewCollision(worldserver, entity, oldBox, newBox);
+                        // Chiyogami start - VanillaSource parallel bridge
+                        //teleportBack = this.hasNewCollision(worldserver, entity, oldBox, newBox);
+                        world.chiyogami.bridge.ParallelEntityMoveHandler moveHandler = this.parallelEntityMoveHandler;
+                        if (moveHandler != null) {
+                            org.bukkit.util.BoundingBox boundingBox = new org.bukkit.util.BoundingBox(oldBox.minX, oldBox.minY, oldBox.minZ, oldBox.maxX, oldBox.maxY, oldBox.maxZ);
+                            org.bukkit.util.Vector movement = new org.bukkit.util.Vector(toX - fromX, toY - fromY, toZ - fromZ);
+                            teleportBack = moveHandler.tryToMoveBoundingBox(boundingBox, movement);
+                        } else {
+                            teleportBack = this.hasNewCollision(worldserver, entity, oldBox, newBox);
+                        }
+                        // Chiyogami end
                     } // else: no collision at all detected, why do we care?
                 }
                 if (teleportBack) { // Paper end - optimise out extra getCubes
@@ -1595,7 +1606,17 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                                 AABB newBox = this.player.getBoundingBox();
                                 if (didCollide || !axisalignedbb.equals(newBox)) {
                                     // note: only call after setLocation, or else getBoundingBox is wrong
-                                    teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                    // Chiyogami start - VanillaSource parallel bridge
+                                    //teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                    world.chiyogami.bridge.ParallelEntityMoveHandler moveHandler = this.parallelEntityMoveHandler;
+                                    if (moveHandler != null) {
+                                        org.bukkit.util.BoundingBox boundingBox = new org.bukkit.util.BoundingBox(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.maxY, axisalignedbb.maxZ);
+                                        org.bukkit.util.Vector movement = new org.bukkit.util.Vector(currDeltaX, currDeltaY, currDeltaZ);
+                                        teleportBack = moveHandler.tryToMoveBoundingBox(boundingBox, movement);
+                                    } else {
+                                        teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                    }
+                                    // Chiyogami end
                                     // Paper start - Add fail move event
                                     if (teleportBack) {
                                         io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.CLIPPED_INTO_BLOCK,
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index f097ec5b4e3ad6b1a7c464a8cff4f8b2568fcf4f..532e070ab8dbbdc278e72ebf5adb6ea1d82a970a 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -310,6 +310,7 @@ public abstract class PlayerList {
         ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
         Component joinMessage = ichatmutablecomponent; // Paper - Adventure
 
+        playerconnection.parallelEntityMoveHandler = world.chiyogami.bridge.ParallelBridge.getParallelEntityMoveHandler(player.getBukkitEntity()); // Chiyogami - VanillaSource parallel bridge
         playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         ServerStatus serverping = this.server.getStatus();
 
