From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: bea4dev <bea0224@outlook.jp>
Date: Mon, 9 Oct 2023 03:50:04 +0900
Subject: [PATCH] fixed cached list patch


diff --git a/src/main/java/io/papermc/paper/util/CachedLists.java b/src/main/java/io/papermc/paper/util/CachedLists.java
index e08f4e39db4ee3fed62e37364d17dcc5c5683504..30a752b6a6f7407e27eafc640a45f310312bd8af 100644
--- a/src/main/java/io/papermc/paper/util/CachedLists.java
+++ b/src/main/java/io/papermc/paper/util/CachedLists.java
@@ -1,57 +1,185 @@
 package io.papermc.paper.util;
 
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
-import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.util.UnsafeList;
+import org.spigotmc.AsyncCatcher;
+import world.chiyogami.thread.WorldThread;
+
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 public final class CachedLists {
 
+    private final Level level;
+
+    private final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    private boolean tempCollisionListInUse;
+
+    private final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    private boolean tempGetEntitiesListInUse;
+
+    private CachedLists(Level level){
+        this.level = level;
+    }
+
+
+
     // Paper start - optimise collisions
-    static final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
+    static final Map<Level, CachedLists> cashedListMap = new ConcurrentHashMap<>();
 
-    public static UnsafeList<AABB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+    public static List<AABB> getTempCollisionList(Level level) {
+        CachedLists cachedLists = cashedListMap.computeIfAbsent(level, CachedLists::new);
+        if (cachedLists.tempCollisionListInUse) {
             return new UnsafeList<>(16);
         }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
+
+        WorldThread worldThread = cachedLists.level.worldThread;
+        if (worldThread != null) {
+            if (worldThread.getCurrentThread() != Thread.currentThread()) {
+                return new UnsafeList<>(16);
+            }
+        }
+
+        cachedLists.tempCollisionListInUse = true;
+        return cachedLists.TEMP_COLLISION_LIST;
     }
 
-    public static void returnTempCollisionList(List<AABB> list) {
-        if (list != TEMP_COLLISION_LIST) {
+
+    public static List<AABB> getTempCollisionList() {
+        for(CachedLists cachedLists : cashedListMap.values()){
+            WorldThread worldThread = cachedLists.level.worldThread;
+            if (worldThread == null) continue;
+
+            if(Thread.currentThread() == worldThread.getCurrentThread() && !cachedLists.tempCollisionListInUse){
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+
+        if (!AsyncCatcher.isMainThread()) {
+            return new UnsafeList<>(16);
+        }
+
+        UnsafeList<AABB> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListMap.values()){
+            allList.addAll(cachedLists.TEMP_COLLISION_LIST);
+        }
+        return allList;
+    }
+
+    public static void returnTempCollisionList(List<AABB> list, Level level) {
+        CachedLists cachedLists = cashedListMap.get(level);
+        if (cachedLists == null){
+            return;
+        }
+
+        if (cachedLists.TEMP_COLLISION_LIST != list) {
             return;
         }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+
+        cachedLists.TEMP_COLLISION_LIST.setSize(0);
+        cachedLists.tempCollisionListInUse = false;
     }
 
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
+    public static void returnTempCollisionList(List<AABB> list) {
+        for(CachedLists cachedLists : cashedListMap.values()){
+            if(cachedLists.TEMP_COLLISION_LIST == list){
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
 
-    public static UnsafeList<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+        ((UnsafeList<?>)list).setSize(0);
+    }
+
+
+    public static List<Entity> getTempGetEntitiesList(Level level) {
+        if (level == null) {
+            return getTempGetEntitiesList();
+        }
+
+        CachedLists cachedLists = cashedListMap.computeIfAbsent(level, CachedLists::new);
+        if (cachedLists.tempGetEntitiesListInUse) {
             return new UnsafeList<>(16);
         }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+
+        WorldThread worldThread = cachedLists.level.worldThread;
+        if (worldThread != null) {
+            if (worldThread.getCurrentThread() != Thread.currentThread()) {
+                return new UnsafeList<>(16);
+            }
+        }
+
+        cachedLists.tempGetEntitiesListInUse = true;
+        return cachedLists.TEMP_GET_ENTITIES_LIST;
     }
 
-    public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
+    public static List<Entity> getTempGetEntitiesList() {
+        for(CachedLists cachedLists : cashedListMap.values()){
+            WorldThread worldThread = cachedLists.level.worldThread;
+            if (worldThread == null) continue;
+
+            if(Thread.currentThread() == worldThread.getCurrentThread() && !cachedLists.tempGetEntitiesListInUse){
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+
+        if (!AsyncCatcher.isMainThread()) {
+            return new UnsafeList<>(16);
+        }
+
+        UnsafeList<Entity> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListMap.values()){
+            allList.addAll(cachedLists.TEMP_GET_ENTITIES_LIST);
+        }
+        return allList;
+    }
+
+    public static void returnTempGetEntitiesList(List<Entity> list, Level level) {
+        if (level == null) {
+            returnTempGetEntitiesList(list);
             return;
         }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
+
+        for(CachedLists cachedLists : cashedListMap.values()){
+            if(level == cachedLists.level){
+                if (cachedLists.TEMP_GET_ENTITIES_LIST != list) {
+                    return;
+                }
+
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+    }
+
+    public static void returnTempGetEntitiesList(List<Entity> list) {
+        for(CachedLists cachedLists : cashedListMap.values()){
+            if(cachedLists.TEMP_GET_ENTITIES_LIST == list){
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+
+        ((UnsafeList<?>)list).setSize(0);
     }
     // Paper end - optimise collisions
 
     public static void reset() {
         // Paper start - optimise collisions
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
+        //TEMP_COLLISION_LIST.completeReset();
+        for(CachedLists cachedLists : cashedListMap.values()){
+            cachedLists.TEMP_COLLISION_LIST.completeReset();
+            cachedLists.TEMP_GET_ENTITIES_LIST.completeReset();
+        }
+        //TEMP_GET_ENTITIES_LIST.completeReset();
         // Paper end - optimise collisions
     }
 }
diff --git a/src/main/java/io/papermc/paper/util/CollisionUtil.java b/src/main/java/io/papermc/paper/util/CollisionUtil.java
index a87f6380b2c387fb0cdd40d5087b5c93492e3c88..b749c1a609a01e37a646356766369f6c9d928d91 100644
--- a/src/main/java/io/papermc/paper/util/CollisionUtil.java
+++ b/src/main/java/io/papermc/paper/util/CollisionUtil.java
@@ -819,7 +819,13 @@ public final class CollisionUtil {
         // Vanilla for hard collisions has this backwards, and they expand by +epsilon but this causes terrible problems
         // specifically with boat collisions.
         aabb = aabb.inflate(-COLLISION_EPSILON, -COLLISION_EPSILON, -COLLISION_EPSILON);
-        final List<Entity> entities = CachedLists.getTempGetEntitiesList();
+        // Chiyogami start - CachedList
+        net.minecraft.world.level.Level level = null;
+        if (entity != null) {
+            level = entity.level;
+        }
+        final List<Entity> entities = CachedLists.getTempGetEntitiesList(level);
+        // Chiyogami end
         try {
             if (entity != null && entity.hardCollides()) {
                 entityGetter.getEntities(entity, aabb, predicate, entities);
@@ -840,7 +846,7 @@ public final class CollisionUtil {
                 }
             }
         } finally {
-            CachedLists.returnTempGetEntitiesList(entities);
+            CachedLists.returnTempGetEntitiesList(entities, level);
         }
 
         return ret;
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index ab58827001b3b42e44d7f701c390480fed1fa1f1..acc4a1e81beb60a7de4a0c2aea54b933a3d5d150 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1707,7 +1707,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     // Paper end
     // Paper start - optimise out extra getCubes
     private boolean hasNewCollision(final ServerLevel world, final Entity entity, final AABB oldBox, final AABB newBox) {
-        final List<AABB> collisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
+        final List<AABB> collisions = io.papermc.paper.util.CachedLists.getTempCollisionList(world);
         try {
             io.papermc.paper.util.CollisionUtil.getCollisions(world, entity, newBox, collisions, false, true,
                 true, false, null, null);
@@ -1721,7 +1721,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
             return false;
         } finally {
-            io.papermc.paper.util.CachedLists.returnTempCollisionList(collisions);
+            io.papermc.paper.util.CachedLists.returnTempCollisionList(collisions, world);
         }
     }
     // Paper end - optimise out extra getCubes
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 3e25851044b5a7d6ac077fecb1e851f34fa956b8..efe58ff4ab1bf99341496f2f1780125f35751523 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1460,7 +1460,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             return movement;
         }
 
-        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
+        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList(world);
         try {
             final double stepHeight = (double)this.maxUpStep();
             final AABB collisionBox;
@@ -1516,7 +1516,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 return limitedMoveVector;
             }
         } finally {
-            io.papermc.paper.util.CachedLists.returnTempCollisionList(potentialCollisions);
+            io.papermc.paper.util.CachedLists.returnTempCollisionList(potentialCollisions, world);
         }
         // Paper end - optimise collisions
     }
